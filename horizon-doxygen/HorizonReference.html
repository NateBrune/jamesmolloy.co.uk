<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Horizon: Horizon reference guide</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<h1>Horizon reference guide </h1>  </div>
</div>
<div class="contents">
<h2><a class="anchor" id="Concepts"></a>
Concepts</h2>
<p>Horizon is a strongly typed assembly language for a virtual infinite register machine. This allows an easy mapping to LLVM bitcode, and also allows static type and bounds checking for language-level process isolation.</p>
<p>Horizon is inherently object-oriented, but programs are not locked to this paradigm - pure procedural is possible also. Functional paradigms naturally degrade to imperative code when compiled, so this is not supported natively.</p>
<p>As a typed assembly / IR language, Horizon has very little lexical scoping. Registers are in scope for the entirety of their enclosing function, with the one exception of registers defined inside closures (and unreferenced throughout the rest of the function_, which only last for the duration of that closure.</p>
<p>Horizon is designed to allow compile-time reflection - as a target for high level languages it was deemed important to allow modules written in different HLLs to interact with each other - hence the adoption of an object-oriented architecture instead of pure procedural (as important OO-&gt;procedural mappings would be difficult to reconstruct once lost). This is also the reason for keeping polymorphic types (Horizon's OCaml style equivalent of C++ templates or Ada generics) in the bytecode.</p>
<p>The class model is single-inheritance with interfaces, Java and C# style. This is widely adopted by other langauges and is much easier to implement and has fewer booby traps than C++'s multiple inheritance model.</p>
<h3><a class="anchor" id="GeneralSyntax"></a>
General syntax rules</h3>
<ul>
<li>Registers are prefixed with a <code>%</code> sign; <code>register</code>.</li>
<li>Registers do not need to be declared before they are used, however they must be used as the destination operand of an instruction before they are used as the source.</li>
<li>Functions, when accessed as function pointers, are prefixed by an <code>@</code>; <code>@func</code>.</li>
<li>Labels are postfixed with a colon, <code></code>:.</li>
<li>All instructions are seperated by newlines, not semicolons.</li>
<li>With the exception of seperating instructions, whitespace is ignored.</li>
<li>Unlike in C++, class declarations do <b>not</b> have a trailing semicolon.</li>
<li>Some instructions, such as <a class="el" href="HorizonReference.html#call">call</a> or <a class="el" href="HorizonReference.html#mov">mov</a> can take constants as parameters. When specifying an integer or floating point constant, the number can be followed by a bitwidth in angle brackets, for example "42 \&lt;8\&gt;" would specify an <code>i8</code> constant with value <code>42</code>. If the bitwidth is omitted, integers default to <code>nativeint</code> type (usually <code>i64</code>), and floats to <code>float</code> (32-bit).</li>
</ul>
<div align="center">
<img src="inline_dotgraph_2.dot.png" alt="inline_dotgraph_2.dot" border="0" usemap="#inline_dotgraph_2.dot.map">
<map name="inline_dotgraph_2.dot.map" id="inline_dotgraph_2.dot.map"><area shape="rect" id="node1" href="HorizonReference.html#Types" title="Types" alt="" coords="141,105,213,154"/><area shape="rect" id="node2" href="HorizonReference.html#BasicTypes" title="Basic Types" alt="" coords="5,6,99,55"/><area shape="rect" id="node3" href="HorizonReference.html#DerivedTypes" title="Derived Types" alt="" coords="123,6,232,55"/><area shape="rect" id="node4" href="HorizonReference.html#PolymorphicTypes" title="Polymorphic Types" alt="" coords="256,6,389,55"/><area shape="rect" id="node5" href="HorizonReference.html#Declarations" title="Declarations" alt="" coords="528,203,627,253"/><area shape="rect" id="node6" href="HorizonReference.html#Classes" title="Classes" alt="" coords="237,105,309,154"/><area shape="rect" id="node7" href="HorizonReference.html#Interfaces" title="Interfaces" alt="" coords="333,105,419,154"/><area shape="rect" id="node8" href="HorizonReference.html#Variants" title="Variants" alt="" coords="443,105,515,154"/><area shape="rect" id="node9" href="HorizonReference.html#Typedefs" title="Typedefs" alt="" coords="539,105,616,154"/><area shape="rect" id="node10" href="HorizonReference.html#Consts" title="Consts" alt="" coords="640,105,712,154"/><area shape="rect" id="node11" href="HorizonReference.html#Using" title="Using Directives" alt="" coords="736,105,859,154"/><area shape="rect" id="node12" href="HorizonReference.html#Functions" title="Functions" alt="" coords="883,105,963,154"/><area shape="rect" id="node13" href="HorizonReference.html#Closures" title="Closures" alt="" coords="831,6,905,55"/><area shape="rect" id="node14" href="HorizonReference.html#Instructions" title="Instructions" alt="" coords="929,6,1023,55"/></map>
</div>
<h2><a class="anchor" id="Types"></a>
Types</h2>
<h3><a class="anchor" id="BasicTypes"></a>
Basic Types</h3>
<p>The basic types are integers and floating point numbers. Integers are always unsigned (although member functions in each integer class can treat them as signed, like <code>smul</code>). The integer types range from <code>i1</code> to <code>i64</code> , just like their LLVM counterparts. <code>float</code> is 32-bits wide, <code>double</code> is 64-bits wide.</p>
<p>There is no 'boolean' - this is simple <code>i1</code>.</p>
<p>Basic types are passed by value.</p>
<h3><a class="anchor" id="DerivedTypes"></a>
Reference Types</h3>
<p>Reference types are any class instantiation or variant instantiation, and the builtin classes such as System.Array.</p>
<p>These are passed by reference (hence the name).</p>
<h3><a class="anchor" id="PolymorphicTypes"></a>
Polymorphic Types</h3>
<p>These are generics, and can be inferred by the compiler. A polymorphic type is signified by a single quote (') preceding an identifier: <code>'a</code>.</p>
<p>Polymorphic types can be members of classes (in which case the class itself becomes polymorphic on that type) or parameters in functions, or simply within a function to ease typing. They are usually able to be inferred by the compiler, however in some cases (such as when <code>alloc</code> ing a new object) it is necessary to inform the compiler about how the types should be instantiated.</p>
<p>This is done using <em>binding</em> <em>lists</em>, written thus:</p>
<div class="fragment"><pre class="fragment">alloc %x : MyType&lt;&#39;ty =&gt; i32&gt;
</pre></div><p>In some cases (at the moment only for the builtin type System.Array) it is necessary to specify not just a type but an integer value too - this is used for the length attribute of a new array:</p>
<div class="fragment"><pre class="fragment">alloc %x : System.Array&lt;<span class="stringliteral">&#39;a =&gt; i32, `l =&gt; 64&gt;</span>
</pre></div><p>Note the backtick (`) instead of the quote (') to show we are defining an integer, not a type mapping.</p>
<h2><a class="anchor" id="Declarations"></a>
Declarations</h2>
<p>At the top level of a horizon assembly file are declarations. These include <a class="el" href="HorizonReference.html#Classes">classes</a>, <a class="el" href="HorizonReference.html#Functions">functions</a>, <a class="el" href="HorizonReference.html#Interfaces">interfaces</a>, <a class="el" href="HorizonReference.html#Variants">variants</a>, <a class="el" href="HorizonReference.html#Typedefs">typedefs</a> and <a class="el" href="HorizonReference.html#Using">using directives</a> (include statements).</p>
<h3><a class="anchor" id="Classes"></a>
Classes</h3>
<div class="fragment"><pre class="fragment"><span class="keyword">class </span><a class="code" href="opcmap_8c.html#ac4cf4b2ab929bd23951a8676eeac086b">C</a> [<span class="keyword">extends</span> <a class="code" href="opcmap_8c.html#af316c33cc298530f245e8b55330e86b5">D</a>] [implements <a class="code" href="opcmap_8c.html#a07484107e6d9fdf38b53edf631d6511d">E</a> [, F...]] {
    [<span class="keyword">static</span>] [<span class="keyword">virtual</span>] function (&lt;returns&gt;) func (&lt;params&gt;)

    [static] variable v : &lt;type&gt; = &lt;initialiser&gt;
}
</pre></div><p>A class can contain member functions and variables. The static and virtual keywords mean the same as in C++. Note that every function can return multiple values, so the return values are enclosed in () as well as the parameters.</p>
<p>Member variables can be of any type, however the initialiser must follow that type. Basic types can have any constant as an initialiser - reference types can only have <code>null</code>.</p>
<p>If <code>null</code> is not provided, then a new instance of the type specified (assuming it is a not an interface type) will be created. Escape analysis will be done to determine if the object should live on the heap or stack.</p>
<p>Classes can <code>extend</code> (subclass) one or zero classes and may <code>implement</code> any number of interfaces.</p>
<h3><a class="anchor" id="Interfaces"></a>
Interfaces</h3>
<div class="fragment"><pre class="fragment">interface I {
    function (&lt;returns&gt;) func (&lt;params&gt;)
}
</pre></div><p>Interfaces are like abstract classes - they can only contain function declarations; no definitions or member variables. A class implementing an interface is a declaration that it contains definitions for all functions in said interface.</p>
<h3><a class="anchor" id="Variants"></a>
Variants</h3>
<div class="fragment"><pre class="fragment">variant <a class="code" href="opcmap_8c.html#af40a326b23c68a27cebe60f16634a2cb">V</a> {
    variable x : i8
    variable y : <span class="keywordtype">float</span>
    variable z : System.Array
}
</pre></div><p>Variants are tagged union types. A runtime error will be raised if the user attempts to load a value from a variant member that was not stored - for example:</p>
<div class="fragment"><pre class="fragment">alloc %v : <a class="code" href="opcmap_8c.html#af40a326b23c68a27cebe60f16634a2cb">V</a>
mov %tmp, 42 &lt;8&gt;
store %v.x, %tmp

<a class="codeRef" href="namespaceboost_1_1serialization.html#f53de6187217c215a1388fd816a678af">load</a> %tmp2, %v.y
</pre></div><p>The above code will fault as an <code>i8</code> has been written, but a <code>float</code> is attempted to be read.</p>
<h3><a class="anchor" id="Typedefs"></a>
Typedefs</h3>
<div class="fragment"><pre class="fragment"><span class="keyword">typedef</span> X Y
</pre></div><p>A typedef sets up an alias from type X to type Y, such that <code>Y</code> can be used anywhere one could use <code>X</code>.</p>
<h3><a class="anchor" id="Consts"></a>
Consts</h3>
<div class="fragment"><pre class="fragment"><span class="keyword">const</span> i8 x = 42
</pre></div><p>A const defines a symbolic constant that can be used anywhere a normal constant could (<a class="el" href="HorizonReference.html#call">call</a> and <a class="el" href="HorizonReference.html#mov">mov</a> instructions).</p>
<h3><a class="anchor" id="Using"></a>
'Using' directives</h3>
<div class="fragment"><pre class="fragment"><span class="keyword">using</span> MyPackage
</pre></div><p>Using directives are horizon's include mechanism. The identifier given to 'using' is interpreted as a package name and will be looked for in the default package path (see the Linker documentation).</p>
<h3><a class="anchor" id="Functions"></a>
Commands inside a define or function</h3>
<div class="fragment"><pre class="fragment">function (ReturnType1, ReturnType2) fn (%param_name : ParamType) {
    &lt;instructions&gt;
&lt;label&gt;:
    &lt;instructions&gt;
}
</pre></div><p>Functions are the main code constructs. Functions can return multiple values (or none) and can take any number of parameters. They contain a sequence of instructions and labels; the labels (and all registers) are limited in scope to the function definition.</p>
<h2><a class="anchor" id="Instructions"></a>
Instructions</h2>
<h3><a class="anchor" id="alloc"></a>
alloc</h3>
<p><em>Create an object</em></p>
<div class="fragment"><pre class="fragment">alloc %x : i32
</pre></div><p>Creates a new object of the given type (in this case <code>i32</code>) and stores a reference to it in the register (in this case <code>x</code>).</p>
<p>The object is created either on the stack or the heap. This is decided by the compiler and is determined by escape analysis on the register. If the object escapes to another function, it is created on the heap to be garbage collected. Otherwise it is safe to allocate the object on the heap.</p>
<p>For manual memory management, see the builtin 'malloc'.</p>
<h3><a class="anchor" id="asm"></a>
asm</h3>
<p><em>Embed inline assembler</em></p>
<div class="fragment"><pre class="fragment"><span class="keyword">asm</span> [sideeffect] [alignstack] {
    <a class="codeRef" doxygen="DoxytagsLLVM:http://llvm.org/doxygen/" href="http://llvm.org/doxygen/namespacellvm_1_1APIntOps.html#f6c95b4a4dd2ba3d713aa877eb4c43a1">add</a> %eax, $2
    <a class="codeRef" doxygen="DoxytagsLLVM:http://llvm.org/doxygen/" href="http://llvm.org/doxygen/namespacellvm_1_1APIntOps.html#e61245e52f0b562481fb1dce023c2f6a">mul</a> %eax, %0
} : (a) %out : (r) %in
</pre></div><p>This instruction embeds a piece of inline assembler. Only a subset of asm is supported; no jumps, calls, returns, or privileged instructions are allowed. The constraints follow the same form as for the GCC inline assembler, but only integer, floating point or array types (of integers or floating point) are allowed.</p>
<p>A parser will analyse the assembler, checking for correctness. register-relative offsets are not allowed, so SIB-byte addressing is completely disallowed. Only constant offsets can be used for load and store operations, so that the extent to which an operand is accessed may be statically calculated (and checked against the operand's array length or size).</p>
<p><em>Note:</em> This instruction will not compile correctly until the LLVM MC project's JIT support is online.</p>
<h3><a class="anchor" id="b"></a>
b</h3>
<p><em>Unconditional branch</em></p>
<div class="fragment"><pre class="fragment">b mylabel
...
mylabel:
</pre></div><p>The <code>b</code> instruction causes control flow to change unconditionally to the label named. The label must be in the current block - that is, the current function or closure.</p>
<h3><a class="anchor" id="bc"></a>
bc</h3>
<p><em>Conditional branch</em></p>
<div class="fragment"><pre class="fragment">bc %c, true_label, false_label
</pre></div><p>Changes control flow to either <code>true_label</code> or <code>false_label</code> dependent on the <code>i1</code> value in <code>c</code>. If <code>c</code> == 1, the instruction jumps to <code>true_label</code>. Else, <code>false_label</code>.</p>
<h3><a class="anchor" id="call"></a>
call</h3>
<p><em>Call a function</em></p>
<div class="fragment"><pre class="fragment">(i)   call fn 1, %a, 2
(ii)  call %a, %b fn 1, 2, 3
(iii) call %a *%b.add 1
(iv)  call %a *%b 1, 2, 3
</pre></div><p><code>call</code> has several syntax forms. In (i) a function <code>fn</code> is called with three parameters. <code>fn</code> here returns no variables.</p>
<p>In (ii) the same function is called but here it returns two parameters. The registers to store those return values in are written before the function name and are comma-separated.</p>
<p>In (iii) a member function <code>add</code> of register <code>b</code> is called, with a single parameter <code>1</code> and a single return value, stored in <code>a</code>. The asterisk before the register to dereference is required in order to distinguish return values from the call target.</p>
<p>in (iv) a function pointer is called. In Horizon function pointers are instantiations of the special interface System.Runnable, created with the <a class="el" href="HorizonReference.html#mov">mov</a> instruction . Note that the asterisk notation is still required in this form.</p>
<h3><a class="anchor" id="casts"></a>
{d,u,i}cast, sext, zext, trunc</h3>
<div class="fragment"><pre class="fragment">dcast %dest : Type, %src
</pre></div><h4><a class="anchor" id="dcast"></a>
dcast</h4>
<p><em>Downcasts an object to a subclass</em></p>
<p>Dynamically checks if <code>src</code> is an instance of (or an instance of a superclass or subclass of) <code>Type</code>. If so, <code>dest</code> will contain <code>src</code> casted to <code>Type</code>.</p>
<p>Note that this should only be used to cast <b>down</b> the inheritance tree, not up. See <a class="el" href="HorizonReference.html#ucast">ucast</a>.</p>
<p>If <code>src</code> is not castable to <code>Type</code>, a runtime error will be raised and the program terminated. Use <a class="el" href="HorizonReference.html#is_a">is-a?</a> to check for castibility.</p>
<h4><a class="anchor" id="ucast"></a>
ucast</h4>
<p><em>Upcasts an object to a superclass</em></p>
<p>Statically checks if <code>src</code> is subclassed from <code>Type</code>, and if so <code>dest</code> will contain <code>src</code> casted to <code>Type</code>. Else a compile-time error will be raised.</p>
<h4><a class="anchor" id="icast"></a>
icast</h4>
<p><em>Casts a class instantiation to an Interface</em></p>
<p>Statically checks if the class of <code>src</code> implements interface <code>Type</code>. If so, <code>dest</code> will contain a reference to the interface <code>Type</code> populated by <code>src</code>, else a compile time error will be raised.</p>
<h4><a class="anchor" id="sext"></a>
sext</h4>
<p><em>Sign-extension</em></p>
<p>Sign-extends the integer value in <code>src</code> to the type <code>Type</code>. <code>src</code> must contain an integer value, and <code>Type</code> must be of integer type and greater than <code>src</code> in bitwidth.</p>
<h4><a class="anchor" id="zext"></a>
zext</h4>
<p><em>Zero-extension</em></p>
<p>Zero-extends the integer value in <code>src</code> to the type <code>Type</code>. <code>src</code> must contain an integer value, and <code>Type</code> must be of integer type and greater than <code>src</code> in bitwidth.</p>
<h4><a class="anchor" id="trunc"></a>
trunc</h4>
<p><em>Truncation</em></p>
<p>Truncates (shortens) the integer value in <code>src</code> to the type <code>Type</code>. <code>src</code> must contain an integer value, and <code>Type</code> must be of integer type and less than <code>src</code> in bitwidth.</p>
<h3><a class="anchor" id="eq"></a>
eq?</h3>
<p><em>Checks references for pointer equality</em></p>
<div class="fragment"><pre class="fragment">eq? %c, %x, %y
</pre></div><p>The <code>eq</code>? instruction checks both arguments for referential equality - i.e. do they point to the same instance?. This instruction can only be used on reference types and performs a shallow equality check only.</p>
<p>The types of <code>x</code> and <code>y</code> must be identical. If the arguments <code>x</code> and <code>y</code> do point to the same object, the register <code>c</code> (which must be of <code>i1</code> type) is populated with the value <code>1</code>. Else, it is given the value <code>0</code>.</p>
<h3><a class="anchor" id="is_a"></a>
is-a?</h3>
<p><em>Checks for castibility</em></p>
<div class="fragment"><pre class="fragment">is-a? %c, %x : MyType
</pre></div><p><code>c</code> (which must be of <code>i1</code> type) will be populated with the value <code>1</code> if <code>x</code> is downcastable to the type <code>MyType</code>. This instruction is used as a runtime check before using the <a class="el" href="HorizonReference.html#dcast">dcast</a> instruction, which causes a program error on failure.</p>
<h3><a class="anchor" id="load"></a>
load</h3>
<p><em>Load a value from a class, global or array</em></p>
<div class="fragment"><pre class="fragment">(i)   load %target, global_variable
(ii)  <a class="codeRef" href="namespaceboost_1_1serialization.html#f53de6187217c215a1388fd816a678af">load</a> %target, %<span class="keywordtype">object</span>.member
(iii) <a class="codeRef" href="namespaceboost_1_1serialization.html#f53de6187217c215a1388fd816a678af">load</a> %target, %array[%index]
</pre></div><p>The <code>load</code> instruction has several forms. In its first form (i) it is used to load the value of a global variable into a register.</p>
<p>In its second form (ii) it is used to load the value of the member variable <code>member</code> from the object referenced by register <code>object</code> into register <code>target</code>.</p>
<p>In its third form (iii) it indexes an array. If <code>array</code> is of class <code>System.Array</code> and <code>index</code> is an integer or constant, <code>target</code> is loaded with the value of the array at the specified index.</p>
<h3><a class="anchor" id="mov"></a>
mov</h3>
<p><em>Copy register</em></p>
<div class="fragment"><pre class="fragment">(i)   mov %dest, %src
(ii)  mov %fnptr, @func
(iii) mov %fnptr, @%obj.func
(iv)  mov %fnptr, closure (i8) (%a : i32, %b : i64) {...}
</pre></div><p>The <code>mov</code> instruction has several forms. In the first and simplest form, it duplicates the contents of <code>src</code> into <code>dest</code>.</p>
<p>In the other forms, it populates the destination register (<code>fnptr</code>) with an instantiation of the builtin interface <code>System.Runnable</code>. This can come from multiple sources; from a function pointer, as in (ii), a member function pointer (iii), or a closure (iv - see <a class="el" href="HorizonReference.html#Closures">Closures</a>).</p>
<h3><a class="anchor" id="null"></a>
null?</h3>
<p><em>Test for NULL pointer</em></p>
<div class="fragment"><pre class="fragment">null? %c, %x
</pre></div><p><code>c</code> (which must be of <code>i1</code> type) is populated with <code>1</code> if <code>x</code> is NULL, <code>0</code> otherwise. This is important as any NULL-pointer dereferences cause an immediate program error.</p>
<h3><a class="anchor" id="par"></a>
par, par-async</h3>
<p><em>Run commands in parallel</em></p>
<div class="fragment"><pre class="fragment">par[-async] {
    call %r1 fn1 %p1, %p2
    call %r2 fn2 %p3, %p4
    call %r3 fn3 %p3, %p4
}
</pre></div><p>The <code>par</code> instruction allows multiple <a class="el" href="HorizonReference.html#call">call</a> instructions to run in parallel. The implementation creates one or more microthreads for this purpose. In the vanilla <code>par</code> instruction, all threads wait at the end of the block (closing brace) for all calls to complete - only then is the next instruction executed.</p>
<p>In the <code>par-async</code> version, the block completes immediately and instructions continue to be executed while the dispatched <a class="el" href="HorizonReference.html#call">call</a> executes.</p>
<p>Note that only <a class="el" href="HorizonReference.html#call">call</a> instructions can live inside a <code>par</code> block, and that if multiple <a class="el" href="HorizonReference.html#call">call</a> instructions share the same return register the value of that register at the end of the block is undefined.</p>
<h4><a class="anchor" id="ParametricQualifiers"></a>
Parametric Qualifiers</h4>
<p><em>Note that these are not yet implemented at the codegen stage.</em></p>
<div class="fragment"><pre class="fragment">par [%i = 0 to 64 step 1] {
   call...
}
</pre></div><p>This version of the <code>par</code> block encodes a "parallel FOR", that takes a "parametric qualifier" before the block. The block is executed (in parallel) for every value of the index register (in this case <code>i</code>), that has scope only in the <code>par</code> block. The start and end values of <code>i</code> can be constants or registers, but must be of integer value.</p>
<h3><a class="anchor" id="ret"></a>
ret</h3>
<p><em>Return from a function</em></p>
<div class="fragment"><pre class="fragment">(i)  ret
(ii) ret %x, %y, %z
</pre></div><p>Returns from a function or closure. A well-formed function must have at least one <code>ret</code> instruction.</p>
<h3><a class="anchor" id="store"></a>
store</h3>
<p><em>Write/index variable</em></p>
<div class="fragment"><pre class="fragment">(i)   store global_variable, %src
(ii)  store %<span class="keywordtype">object</span>.member, %src
(iii) store %array[%index], %src
</pre></div><p>The opposite of <a class="el" href="HorizonReference.html#load">load</a>.</p>
<h2><a class="anchor" id="Closures"></a>
Closures</h2>
<div class="fragment"><pre class="fragment">mov %x, closure (&lt;returns&gt;) (&lt;params&gt;) {
    &lt;instructions&gt;
}
</pre></div><p>Closures are anonymous functions that can also contain an environment. If the only registers that are referenced inside the closure are also referenced outside the closure, no environment is needed and it acts purely like an anonymous function.</p>
<p>If registers are defined inside the closure that are not referenced outside, those registers are considered closure-local and are added to an environment structure which is passed around with the function pointer to the closure, so these registers maintain their state in between invocations of the closure.</p>
<p>Closures have the type <code>System.Runnable</code>. </p>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Wed Sep 29 2010 17:04:02 for Horizon by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
